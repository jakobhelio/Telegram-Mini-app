import{g as Q,c as N,U as _,a as A,C as G,f as F,S as q,b as x,n as U,d as J,R,k as Y,s as $,_ as S,e as W,w as j,h as O,P as k,i as X}from"./index-a3470178.js";import{j as ot}from"./index-a3470178.js";function Z(u,{body:v,onError:l,onResponse:f}){return u.request({body:v,onError:l,onResponse:f}),u}async function E(u,{body:v,timeout:l=1e4}){return u.requestAsync({body:v,timeout:l})}const M={http(u,v){return Q(u).request(v)},webSocket:Z,webSocketAsync:E};K.type="mock";function K(u){const v=new Map,l=u.features??{defaultConnected:!1};let f=l.defaultConnected,p;return N(a=>({id:"mock",name:"Mock Connector",type:K.type,async setup(){p=a.chains[0].id},async connect({chainId:e}={}){if(l.connectError)throw typeof l.connectError=="boolean"?new _(new Error("Failed to connect.")):l.connectError;const i=await(await this.getProvider()).request({method:"eth_requestAccounts"});let c=await this.getChainId();return e&&c!==e&&(c=(await this.switchChain({chainId:e})).id),f=!0,{accounts:i.map(t=>A(t)),chainId:c}},async disconnect(){f=!1},async getAccounts(){if(!f)throw new G;return(await(await this.getProvider()).request({method:"eth_accounts"})).map(i=>A(i))},async getChainId(){const r=await(await this.getProvider()).request({method:"eth_chainId"});return F(r,"number")},async isAuthorized(){return!l.reconnect||!f?!1:!!(await this.getAccounts()).length},async switchChain({chainId:e}){const r=await this.getProvider(),i=a.chains.find(c=>c.id===e);if(!i)throw new q(new x);return await r.request({method:"wallet_switchEthereumChain",params:[{chainId:U(e)}]}),i},onAccountsChanged(e){e.length===0?this.onDisconnect():a.emitter.emit("change",{accounts:e.map(r=>A(r))})},onChainChanged(e){const r=Number(e);a.emitter.emit("change",{chainId:r})},async onDisconnect(e){a.emitter.emit("disconnect"),f=!1},async getProvider({chainId:e}={}){const i=(a.chains.find(t=>t.id===e)??a.chains[0]).rpcUrls.default.http[0];return J({request:async({method:t,params:s})=>{if(t==="eth_chainId")return U(p);if(t==="eth_requestAccounts")return u.accounts;if(t==="eth_signTypedData_v4"&&l.signTypedDataError)throw typeof l.signTypedDataError=="boolean"?new _(new Error("Failed to sign typed data.")):l.signTypedDataError;if(t==="wallet_switchEthereumChain"){if(l.switchChainError)throw typeof l.switchChainError=="boolean"?new _(new Error("Failed to switch chain.")):l.switchChainError;p=F(s[0].chainId,"number"),this.onChainChanged(p.toString());return}if(t==="wallet_watchAsset"){if(l.watchAssetError)throw typeof l.watchAssetError=="boolean"?new _(new Error("Failed to switch chain.")):l.watchAssetError;return f}if(t==="wallet_getCapabilities")return{"0x2105":{paymasterService:{supported:s[0]==="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:s[0]==="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"}}};if(t==="wallet_sendCalls"){const d=[],h=s[0].calls;for(const y of h){const{result:C,error:b}=await M.http(i,{body:{method:"eth_sendTransaction",params:[y]}});if(b)throw new R({body:{method:t,params:s},error:b,url:i});d.push(C)}const g=Y($(JSON.stringify(h)));return v.set(g,d),g}if(t==="wallet_getCallsStatus"){const d=v.get(s[0]);if(!d)return null;const h=await Promise.all(d.map(async g=>{const{result:y,error:C}=await M.http(i,{body:{method:"eth_getTransactionReceipt",params:[g],id:0}});if(C)throw new R({body:{method:t,params:s},error:C,url:i});return y?{blockHash:y.blockHash,blockNumber:y.blockNumber,gasUsed:y.gasUsed,logs:y.logs,status:y.status,transactionHash:y.transactionHash}:null}));return h.some(g=>!g)?{status:"PENDING",receipts:[]}:{status:"CONFIRMED",receipts:h}}if(t==="wallet_showCallsStatus")return;if(t==="personal_sign"){if(l.signMessageError)throw typeof l.signMessageError=="boolean"?new _(new Error("Failed to sign message.")):l.signMessageError;t="eth_sign",s=[s[1],s[0]]}const n={method:t,params:s},{error:o,result:w}=await M.http(i,{body:n});if(o)throw new R({body:n,error:o,url:i});return w}})({retryCount:0})}}))}function m(u){var a,e,r;const{chain:v}=u,l=v.rpcUrls.default.http[0];if(!u.transports)return[l];const f=(e=(a=u.transports)==null?void 0:a[v.id])==null?void 0:e.call(a,{chain:v});return(((r=f==null?void 0:f.value)==null?void 0:r.transports)||[f]).map(({value:i})=>(i==null?void 0:i.url)||l)}T.type="coinbaseWallet";function T(u={}){return u.version==="3"||u.headlessMode?tt(u):P(u)}function P(u){let v,l,f,p;return N(a=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",rdns:"com.coinbase.wallet",type:T.type,async connect({chainId:e,...r}={}){try{const i=await this.getProvider(),c=(await i.request({method:"eth_requestAccounts",params:"instantOnboarding"in r&&r.instantOnboarding?[{onboarding:"instant"}]:[]})).map(s=>A(s));l||(l=this.onAccountsChanged.bind(this),i.on("accountsChanged",l)),f||(f=this.onChainChanged.bind(this),i.on("chainChanged",f)),p||(p=this.onDisconnect.bind(this),i.on("disconnect",p));let t=await this.getChainId();if(e&&t!==e){const s=await this.switchChain({chainId:e}).catch(n=>{if(n.code===_.code)throw n;return{id:t}});t=(s==null?void 0:s.id)??t}return{accounts:c,chainId:t}}catch(i){throw/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(i.message)?new _(i):i}},async disconnect(){var r;const e=await this.getProvider();l&&(e.removeListener("accountsChanged",l),l=void 0),f&&(e.removeListener("chainChanged",f),f=void 0),p&&(e.removeListener("disconnect",p),p=void 0),e.disconnect(),(r=e.close)==null||r.call(e)},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(r=>A(r))},async getChainId(){const r=await(await this.getProvider()).request({method:"eth_chainId"});return Number(r)},async getProvider(){if(!v){const e=(()=>{var c;return typeof u.preference=="string"?{options:u.preference}:{...u.preference,options:((c=u.preference)==null?void 0:c.options)??"all"}})(),{createCoinbaseWalletSDK:r}=await S(()=>import("./index-2b96a5aa.js"),["assets/index-2b96a5aa.js","assets/index-a3470178.js","assets/index-1774331a.css","assets/hooks.module-5f06edc3.js"]);v=r({...u,appChainIds:a.chains.map(c=>c.id),preference:e}).getProvider()}return v},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:r}){var t,s,n,o;const i=a.chains.find(w=>w.id===r);if(!i)throw new q(new x);const c=await this.getProvider();try{return await c.request({method:"wallet_switchEthereumChain",params:[{chainId:U(i.id)}]}),i}catch(w){if(w.code===4902)try{let d;e!=null&&e.blockExplorerUrls?d=e.blockExplorerUrls:d=(t=i.blockExplorers)!=null&&t.default.url?[(s=i.blockExplorers)==null?void 0:s.default.url]:[];let h;(n=e==null?void 0:e.rpcUrls)!=null&&n.length?h=e.rpcUrls:h=[((o=i.rpcUrls.default)==null?void 0:o.http[0])??""];const g={blockExplorerUrls:d,chainId:U(r),chainName:(e==null?void 0:e.chainName)??i.name,iconUrls:e==null?void 0:e.iconUrls,nativeCurrency:(e==null?void 0:e.nativeCurrency)??i.nativeCurrency,rpcUrls:h};return await c.request({method:"wallet_addEthereumChain",params:[g]}),i}catch(d){throw new _(d)}throw new q(w)}},onAccountsChanged(e){e.length===0?this.onDisconnect():a.emitter.emit("change",{accounts:e.map(r=>A(r))})},onChainChanged(e){const r=Number(e);a.emitter.emit("change",{chainId:r})},async onDisconnect(e){a.emitter.emit("disconnect");const r=await this.getProvider();l&&(r.removeListener("accountsChanged",l),l=void 0),f&&(r.removeListener("chainChanged",f),f=void 0),p&&(r.removeListener("disconnect",p),p=void 0)}}))}function tt(u){let l,f,p,a,e;return N(r=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",type:T.type,async connect({chainId:i}={}){try{const c=await this.getProvider(),t=(await c.request({method:"eth_requestAccounts"})).map(n=>A(n));p||(p=this.onAccountsChanged.bind(this),c.on("accountsChanged",p)),a||(a=this.onChainChanged.bind(this),c.on("chainChanged",a)),e||(e=this.onDisconnect.bind(this),c.on("disconnect",e));let s=await this.getChainId();if(i&&s!==i){const n=await this.switchChain({chainId:i}).catch(o=>{if(o.code===_.code)throw o;return{id:s}});s=(n==null?void 0:n.id)??s}return{accounts:t,chainId:s}}catch(c){throw/(user closed modal|accounts received is empty|user denied account)/i.test(c.message)?new _(c):c}},async disconnect(){const i=await this.getProvider();p&&(i.removeListener("accountsChanged",p),p=void 0),a&&(i.removeListener("chainChanged",a),a=void 0),e&&(i.removeListener("disconnect",e),e=void 0),i.disconnect(),i.close()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(c=>A(c))},async getChainId(){const c=await(await this.getProvider()).request({method:"eth_chainId"});return Number(c)},async getProvider(){var i;if(!f){const c=await(async()=>{const{default:w}=await S(()=>import("./index-378880dc.js").then(d=>d.i),["assets/index-378880dc.js","assets/index-a3470178.js","assets/index-1774331a.css","assets/hooks.module-5f06edc3.js","assets/browser-ff359600.js"]);return typeof w!="function"&&typeof w.default=="function"?w.default:w})();l=new c({...u,reloadOnDisconnect:!1});const t=(i=l.walletExtension)==null?void 0:i.getChainId(),s=r.chains.find(w=>u.chainId?w.id===u.chainId:w.id===t)||r.chains[0],n=u.chainId||(s==null?void 0:s.id),o=u.jsonRpcUrl||(s==null?void 0:s.rpcUrls.default.http[0]);f=l.makeWeb3Provider(o,n)}return f},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:i,chainId:c}){var n,o,w,d;const t=r.chains.find(h=>h.id===c);if(!t)throw new q(new x);const s=await this.getProvider();try{return await s.request({method:"wallet_switchEthereumChain",params:[{chainId:U(t.id)}]}),t}catch(h){if(h.code===4902)try{let g;i!=null&&i.blockExplorerUrls?g=i.blockExplorerUrls:g=(n=t.blockExplorers)!=null&&n.default.url?[(o=t.blockExplorers)==null?void 0:o.default.url]:[];let y;(w=i==null?void 0:i.rpcUrls)!=null&&w.length?y=i.rpcUrls:y=[((d=t.rpcUrls.default)==null?void 0:d.http[0])??""];const C={blockExplorerUrls:g,chainId:U(c),chainName:(i==null?void 0:i.chainName)??t.name,iconUrls:i==null?void 0:i.iconUrls,nativeCurrency:(i==null?void 0:i.nativeCurrency)??t.nativeCurrency,rpcUrls:y};return await s.request({method:"wallet_addEthereumChain",params:[C]}),t}catch(g){throw new _(g)}throw new q(h)}},onAccountsChanged(i){i.length===0?this.onDisconnect():r.emitter.emit("change",{accounts:i.map(c=>A(c))})},onChainChanged(i){const c=Number(i);r.emitter.emit("change",{chainId:c})},async onDisconnect(i){r.emitter.emit("disconnect");const c=await this.getProvider();p&&(c.removeListener("accountsChanged",p),p=void 0),a&&(c.removeListener("chainChanged",a),a=void 0),e&&(c.removeListener("disconnect",e),e=void 0)}}))}H.type="metaMask";function H(u={}){let v,l,f,p,a,e,r,i;return N(c=>({id:"metaMaskSDK",name:"MetaMask",rdns:["io.metamask","io.metamask.mobile"],type:H.type,async setup(){const t=await this.getProvider();t!=null&&t.on&&(e||(e=this.onConnect.bind(this),t.on("connect",e)),p||(p=this.onAccountsChanged.bind(this),t.on("accountsChanged",p)))},async connect({chainId:t,isReconnecting:s}={}){const n=await this.getProvider();r||(r=this.onDisplayUri,n.on("display_uri",r));let o=[];s&&(o=await this.getAccounts().catch(()=>[]));try{let w,d;o!=null&&o.length||(u.connectAndSign||u.connectWith?(u.connectAndSign?w=await v.connectAndSign({msg:u.connectAndSign}):u.connectWith&&(d=await v.connectWith({method:u.connectWith.method,params:u.connectWith.params})),o=await this.getAccounts()):o=(await v.connect()).map(y=>A(y)));let h=await this.getChainId();if(t&&h!==t){const g=await this.switchChain({chainId:t}).catch(y=>{if(y.code===_.code)throw y;return{id:h}});h=(g==null?void 0:g.id)??h}return r&&(n.removeListener("display_uri",r),r=void 0),w?n.emit("connectAndSign",{accounts:o,chainId:h,signResponse:w}):d&&n.emit("connectWith",{accounts:o,chainId:h,connectWithResponse:d}),e&&(n.removeListener("connect",e),e=void 0),p||(p=this.onAccountsChanged.bind(this),n.on("accountsChanged",p)),a||(a=this.onChainChanged.bind(this),n.on("chainChanged",a)),i||(i=this.onDisconnect.bind(this),n.on("disconnect",i)),{accounts:o,chainId:h}}catch(w){const d=w;throw d.code===_.code?new _(d):d.code===W.code?new W(d):d}},async disconnect(){const t=await this.getProvider();a&&(t.removeListener("chainChanged",a),a=void 0),i&&(t.removeListener("disconnect",i),i=void 0),e||(e=this.onConnect.bind(this),t.on("connect",e)),await v.terminate()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(n=>A(n))},async getChainId(){const t=await this.getProvider(),s=t.getChainId()||await(t==null?void 0:t.request({method:"eth_chainId"}));return Number(s)},async getProvider(){async function t(){var d,h,g,y,C;const s=await(async()=>{const{default:b}=await S(()=>import("./metamask-sdk-3e1d102a.js"),["assets/metamask-sdk-3e1d102a.js","assets/index-a3470178.js","assets/index-1774331a.css","assets/browser-ff359600.js"]);return typeof b!="function"&&typeof b.default=="function"?b.default:b})(),n={};for(const b of c.chains)n[U(b.id)]=(d=m({chain:b,transports:c.transports}))==null?void 0:d[0];v=new s({_source:"wagmi",forceDeleteProvider:!1,forceInjectProvider:!1,injectProvider:!1,...u,readonlyRPCMap:n,dappMetadata:{...u.dappMetadata,name:(h=u.dappMetadata)!=null&&h.name?(g=u.dappMetadata)==null?void 0:g.name:"wagmi",url:(y=u.dappMetadata)!=null&&y.url?(C=u.dappMetadata)==null?void 0:C.url:typeof window<"u"?window.location.origin:"https://wagmi.sh"},useDeeplink:u.useDeeplink??!0});const o=await v.init(),w=(()=>o!=null&&o.activeProvider?o.activeProvider:v.getProvider())();if(!w)throw new k;return w}return l||(f||(f=t()),l=await f),l},async isAuthorized(){try{return!!(await j(()=>O(()=>this.getAccounts(),{timeout:200}),{delay:201,retryCount:3})).length}catch{return!1}},async switchChain({addEthereumChainParameter:t,chainId:s}){var h,g;const n=await this.getProvider(),o=c.chains.find(y=>y.id===s);if(!o)throw new q(new x);try{return await n.request({method:"wallet_switchEthereumChain",params:[{chainId:U(s)}]}),await w(),await d(s),o}catch(y){const C=y;if(C.code===_.code)throw new _(C);if(C.code===4902||((g=(h=C==null?void 0:C.data)==null?void 0:h.originalError)==null?void 0:g.code)===4902)try{return await n.request({method:"wallet_addEthereumChain",params:[{blockExplorerUrls:(()=>{const{default:b,...I}=o.blockExplorers??{};if(t!=null&&t.blockExplorerUrls)return t.blockExplorerUrls;if(b)return[b.url,...Object.values(I).map(D=>D.url)]})(),chainId:U(s),chainName:(t==null?void 0:t.chainName)??o.name,iconUrls:t==null?void 0:t.iconUrls,nativeCurrency:(t==null?void 0:t.nativeCurrency)??o.nativeCurrency,rpcUrls:(()=>{var b,I;return(b=t==null?void 0:t.rpcUrls)!=null&&b.length?t.rpcUrls:[((I=o.rpcUrls.default)==null?void 0:I.http[0])??""]})()}]}),await w(),await d(s),o}catch(b){const I=b;throw I.code===_.code?new _(I):new q(I)}throw new q(C)}async function w(){await j(async()=>{const y=X(await n.request({method:"eth_chainId"}));if(y!==s)throw new Error("User rejected switch after adding network.");return y},{delay:50,retryCount:20})}async function d(y){await new Promise(C=>{const b=I=>{"chainId"in I&&I.chainId===y&&(c.emitter.off("change",b),C())};c.emitter.on("change",b),c.emitter.emit("change",{chainId:y})})}},async onAccountsChanged(t){if(t.length===0)if(v.isExtensionActive())this.onDisconnect();else return;else if(c.emitter.listenerCount("connect")){const s=(await this.getChainId()).toString();this.onConnect({chainId:s})}else c.emitter.emit("change",{accounts:t.map(s=>A(s))})},onChainChanged(t){const s=Number(t);c.emitter.emit("change",{chainId:s})},async onConnect(t){const s=await this.getAccounts();if(s.length===0)return;const n=Number(t.chainId);c.emitter.emit("connect",{accounts:s,chainId:n});const o=await this.getProvider();e&&(o.removeListener("connect",e),e=void 0),p||(p=this.onAccountsChanged.bind(this),o.on("accountsChanged",p)),a||(a=this.onChainChanged.bind(this),o.on("chainChanged",a)),i||(i=this.onDisconnect.bind(this),o.on("disconnect",i))},async onDisconnect(t){const s=await this.getProvider();t&&t.code===1013&&s&&(await this.getAccounts()).length||(c.emitter.emit("disconnect"),a&&(s.removeListener("chainChanged",a),a=void 0),i&&(s.removeListener("disconnect",i),i=void 0),e||(e=this.onConnect.bind(this),s.on("connect",e)))},onDisplayUri(t){c.emitter.emit("message",{type:"display_uri",data:t})}}))}V.type="safe";function V(u={}){const{shimDisconnect:v=!1}=u;let l,f;return N(p=>({id:"safe",name:"Safe",type:V.type,async connect(){var i;const a=await this.getProvider();if(!a)throw new k;const e=await this.getAccounts(),r=await this.getChainId();return f||(f=this.onDisconnect.bind(this),a.on("disconnect",f)),v&&await((i=p.storage)==null?void 0:i.removeItem("safe.disconnected")),{accounts:e,chainId:r}},async disconnect(){var e;const a=await this.getProvider();if(!a)throw new k;f&&(a.removeListener("disconnect",f),f=void 0),v&&await((e=p.storage)==null?void 0:e.setItem("safe.disconnected",!0))},async getAccounts(){const a=await this.getProvider();if(!a)throw new k;return(await a.request({method:"eth_accounts"})).map(A)},async getProvider(){if(typeof window<"u"&&(window==null?void 0:window.parent)!==window){if(!l){const{default:e}=await S(()=>import("./index-4685fb3e.js").then(t=>t.e),["assets/index-4685fb3e.js","assets/index-a3470178.js","assets/index-1774331a.css"]),r=new e(u),i=await O(()=>r.safe.getInfo(),{timeout:u.unstable_getInfoTimeout??10});if(!i)throw new Error("Could not load Safe information");const c=await(async()=>{const t=await S(()=>import("./index-0903afd6.js").then(s=>s.i),["assets/index-0903afd6.js","assets/index-a3470178.js","assets/index-1774331a.css","assets/index-4685fb3e.js"]);return typeof t.SafeAppProvider!="function"&&typeof t.default.SafeAppProvider=="function"?t.default.SafeAppProvider:t.SafeAppProvider})();l=new c(i,r)}return l}},async getChainId(){const a=await this.getProvider();if(!a)throw new k;return Number(a.chainId)},async isAuthorized(){var a;try{return v&&await((a=p.storage)==null?void 0:a.getItem("safe.disconnected"))?!1:!!(await this.getAccounts()).length}catch{return!1}},onAccountsChanged(){},onChainChanged(){},onDisconnect(){p.emitter.emit("disconnect")}}))}z.type="walletConnect";function z(u){const v=u.isNewChainsStale??!0;let l,f;const p="eip155";let a,e,r,i,c,t;return N(s=>({id:"walletConnect",name:"WalletConnect",type:z.type,async setup(){const n=await this.getProvider().catch(()=>null);n&&(r||(r=this.onConnect.bind(this),n.on("connect",r)),c||(c=this.onSessionDelete.bind(this),n.on("session_delete",c)))},async connect({chainId:n,...o}={}){var w,d;try{const h=await this.getProvider();if(!h)throw new k;i||(i=this.onDisplayUri,h.on("display_uri",i));let g=n;if(!g){const I=await((w=s.storage)==null?void 0:w.getItem("state"))??{};s.chains.some(L=>L.id===I.chainId)?g=I.chainId:g=(d=s.chains[0])==null?void 0:d.id}if(!g)throw new Error("No chains found on connector.");const y=await this.isChainsStale();if(h.session&&y&&await h.disconnect(),!h.session||y){const I=s.chains.filter(D=>D.id!==g).map(D=>D.id);await h.connect({optionalChains:[g,...I],..."pairingTopic"in o?{pairingTopic:o.pairingTopic}:{}}),this.setRequestedChainsIds(s.chains.map(D=>D.id))}const C=(await h.enable()).map(I=>A(I)),b=await this.getChainId();return i&&(h.removeListener("display_uri",i),i=void 0),r&&(h.removeListener("connect",r),r=void 0),a||(a=this.onAccountsChanged.bind(this),h.on("accountsChanged",a)),e||(e=this.onChainChanged.bind(this),h.on("chainChanged",e)),t||(t=this.onDisconnect.bind(this),h.on("disconnect",t)),c||(c=this.onSessionDelete.bind(this),h.on("session_delete",c)),{accounts:C,chainId:b}}catch(h){throw/(user rejected|connection request reset)/i.test(h==null?void 0:h.message)?new _(h):h}},async disconnect(){const n=await this.getProvider();try{await(n==null?void 0:n.disconnect())}catch(o){if(!/No matching key/i.test(o.message))throw o}finally{e&&(n==null||n.removeListener("chainChanged",e),e=void 0),t&&(n==null||n.removeListener("disconnect",t),t=void 0),r||(r=this.onConnect.bind(this),n==null||n.on("connect",r)),a&&(n==null||n.removeListener("accountsChanged",a),a=void 0),c&&(n==null||n.removeListener("session_delete",c),c=void 0),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map(o=>A(o))},async getProvider({chainId:n}={}){var w;async function o(){const d=s.chains.map(g=>g.id);if(!d.length)return;const{EthereumProvider:h}=await S(()=>import("./index.es-94236fbb.js"),["assets/index.es-94236fbb.js","assets/index-a3470178.js","assets/index-1774331a.css"]);return await h.init({...u,disableProviderPing:!0,optionalChains:d,projectId:u.projectId,rpcMap:Object.fromEntries(s.chains.map(g=>{const[y]=m({chain:g,transports:s.transports});return[g.id,y]})),showQrModal:u.showQrModal??!0})}return l||(f||(f=o()),l=await f,l==null||l.events.setMaxListeners(Number.POSITIVE_INFINITY)),n&&await((w=this.switchChain)==null?void 0:w.call(this,{chainId:n})),l},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{const[n,o]=await Promise.all([this.getAccounts(),this.getProvider()]);return n.length?await this.isChainsStale()&&o.session?(await o.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:n,chainId:o}){var h,g,y;const w=await this.getProvider();if(!w)throw new k;const d=s.chains.find(C=>C.id===o);if(!d)throw new q(new x);try{await Promise.all([new Promise(b=>{const I=({chainId:D})=>{D===o&&(s.emitter.off("change",I),b())};s.emitter.on("change",I)}),w.request({method:"wallet_switchEthereumChain",params:[{chainId:U(o)}]})]);const C=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...C,o]),d}catch(C){const b=C;if(/(user rejected)/i.test(b.message))throw new _(b);try{let I;n!=null&&n.blockExplorerUrls?I=n.blockExplorerUrls:I=(h=d.blockExplorers)!=null&&h.default.url?[(g=d.blockExplorers)==null?void 0:g.default.url]:[];let D;(y=n==null?void 0:n.rpcUrls)!=null&&y.length?D=n.rpcUrls:D=[...d.rpcUrls.default.http];const L={blockExplorerUrls:I,chainId:U(o),chainName:(n==null?void 0:n.chainName)??d.name,iconUrls:n==null?void 0:n.iconUrls,nativeCurrency:(n==null?void 0:n.nativeCurrency)??d.nativeCurrency,rpcUrls:D};await w.request({method:"wallet_addEthereumChain",params:[L]});const B=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...B,o]),d}catch(I){throw new _(I)}}},onAccountsChanged(n){n.length===0?this.onDisconnect():s.emitter.emit("change",{accounts:n.map(o=>A(o))})},onChainChanged(n){const o=Number(n);s.emitter.emit("change",{chainId:o})},async onConnect(n){const o=Number(n.chainId),w=await this.getAccounts();s.emitter.emit("connect",{accounts:w,chainId:o})},async onDisconnect(n){this.setRequestedChainsIds([]),s.emitter.emit("disconnect");const o=await this.getProvider();a&&(o.removeListener("accountsChanged",a),a=void 0),e&&(o.removeListener("chainChanged",e),e=void 0),t&&(o.removeListener("disconnect",t),t=void 0),c&&(o.removeListener("session_delete",c),c=void 0),r||(r=this.onConnect.bind(this),o.on("connect",r))},onDisplayUri(n){s.emitter.emit("message",{type:"display_uri",data:n})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){var o,w,d;return l?((d=(w=(o=l.session)==null?void 0:o.namespaces[p])==null?void 0:w.accounts)==null?void 0:d.map(h=>Number.parseInt(h.split(":")[1]||"")))??[]:[]},async getRequestedChainsIds(){var n;return await((n=s.storage)==null?void 0:n.getItem(this.requestedChainsStorageKey))??[]},async isChainsStale(){if(!v)return!1;const n=s.chains.map(d=>d.id),o=this.getNamespaceChainsIds();if(o.length&&!o.some(d=>n.includes(d)))return!1;const w=await this.getRequestedChainsIds();return!n.every(d=>w.includes(d))},async setRequestedChainsIds(n){var o;await((o=s.storage)==null?void 0:o.setItem(this.requestedChainsStorageKey,n))},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}}))}const et="5.7.11";export{T as coinbaseWallet,ot as injected,H as metaMask,K as mock,V as safe,et as version,z as walletConnect};
