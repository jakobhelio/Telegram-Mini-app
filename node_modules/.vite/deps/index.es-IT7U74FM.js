import {
  $e,
  Kr,
  de,
  es
} from "./chunk-66KVY5LS.js";
import "./chunk-LFMA7TWF.js";
import {
  require_events
} from "./chunk-6MWCIZWZ.js";
import "./chunk-C4QPDNCK.js";
import "./chunk-Z7ADAFX5.js";
import "./chunk-3MMYMYSM.js";
import "./chunk-B47TRCNG.js";
import "./chunk-SEBPV63G.js";
import "./chunk-IRIDC7YZ.js";
import "./chunk-O3TBTMZ7.js";
import "./chunk-MJ5OW5FL.js";
import {
  __toESM
} from "./chunk-SEVZ5PBP.js";

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var import_events = __toESM(require_events());
var T = "wc";
var $ = "ethereum_provider";
var j = `${T}@2:${$}:`;
var q = "https://rpc.walletconnect.org/v1/";
var u = ["eth_sendTransaction", "personal_sign"];
var M = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode", "wallet_sendCalls", "wallet_getCapabilities", "wallet_getCallsStatus", "wallet_showCallsStatus"];
var m = ["chainChanged", "accountsChanged"];
var O = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var N = Object.defineProperty;
var D = Object.defineProperties;
var U = Object.getOwnPropertyDescriptors;
var P = Object.getOwnPropertySymbols;
var Q = Object.prototype.hasOwnProperty;
var L = Object.prototype.propertyIsEnumerable;
var y = (a, t, s) => t in a ? N(a, t, { enumerable: true, configurable: true, writable: true, value: s }) : a[t] = s;
var g = (a, t) => {
  for (var s in t || (t = {}))
    Q.call(t, s) && y(a, s, t[s]);
  if (P)
    for (var s of P(t))
      L.call(t, s) && y(a, s, t[s]);
  return a;
};
var _ = (a, t) => D(a, U(t));
var o = (a, t, s) => y(a, typeof t != "symbol" ? t + "" : t, s);
function v(a) {
  return Number(a[0].split(":")[1]);
}
function C(a) {
  return `0x${a.toString(16)}`;
}
function x(a) {
  const { chains: t, optionalChains: s, methods: i, optionalMethods: e, events: n, optionalEvents: h, rpcMap: l } = a;
  if (!$e(t))
    throw new Error("Invalid chains");
  const r = { chains: t, methods: i || u, events: n || m, rpcMap: g({}, t.length ? { [v(t)]: l[v(t)] } : {}) }, d = n == null ? void 0 : n.filter((p) => !m.includes(p)), c = i == null ? void 0 : i.filter((p) => !u.includes(p));
  if (!s && !h && !e && !(d != null && d.length) && !(c != null && c.length))
    return { required: t.length ? r : void 0 };
  const I = (d == null ? void 0 : d.length) && (c == null ? void 0 : c.length) || !s, f = { chains: [...new Set(I ? r.chains.concat(s || []) : s)], methods: [...new Set(r.methods.concat(e != null && e.length ? e : M))], events: [...new Set(r.events.concat(h != null && h.length ? h : O))], rpcMap: l };
  return { required: t.length ? r : void 0, optional: s.length ? f : void 0 };
}
var w = class _w {
  constructor() {
    o(this, "events", new import_events.EventEmitter()), o(this, "namespace", "eip155"), o(this, "accounts", []), o(this, "signer"), o(this, "chainId", 1), o(this, "modal"), o(this, "rpc"), o(this, "STORAGE_KEY", j), o(this, "on", (t, s) => (this.events.on(t, s), this)), o(this, "once", (t, s) => (this.events.once(t, s), this)), o(this, "removeListener", (t, s) => (this.events.removeListener(t, s), this)), o(this, "off", (t, s) => (this.events.off(t, s), this)), o(this, "parseAccount", (t) => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t), this.signer = {}, this.rpc = {};
  }
  static async init(t) {
    const s = new _w();
    return await s.initialize(t), s;
  }
  async request(t, s) {
    return await this.signer.request(t, this.formatChainId(this.chainId), s);
  }
  sendAsync(t, s, i) {
    this.signer.sendAsync(t, s, this.formatChainId(this.chainId), i);
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t) {
    if (!this.signer.client)
      throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t);
    const { required: s, optional: i } = x(this.rpc);
    try {
      const e = await new Promise(async (h, l) => {
        var r;
        this.rpc.showQrModal && ((r = this.modal) == null || r.subscribeModal((c) => {
          !c.open && !this.signer.session && (this.signer.abortPairingAttempt(), l(new Error("Connection request reset. Please try again.")));
        }));
        const d = t != null && t.scopedProperties ? { [this.namespace]: t.scopedProperties } : void 0;
        await this.signer.connect(_(g({ namespaces: g({}, s && { [this.namespace]: s }) }, i && { optionalNamespaces: { [this.namespace]: i } }), { pairingTopic: t == null ? void 0 : t.pairingTopic, scopedProperties: d })).then((c) => {
          h(c);
        }).catch((c) => {
          l(new Error(c.message));
        });
      });
      if (!e)
        return;
      const n = Kr(e.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit("connect", { chainId: C(this.chainId) });
    } catch (e) {
      throw this.signer.logger.error(e), e;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async authenticate(t, s) {
    if (!this.signer.client)
      throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts({ chains: t == null ? void 0 : t.chains });
    try {
      const i = await new Promise(async (n, h) => {
        var l;
        this.rpc.showQrModal && ((l = this.modal) == null || l.subscribeModal((r) => {
          !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), h(new Error("Connection request reset. Please try again.")));
        })), await this.signer.authenticate(_(g({}, t), { chains: this.rpc.chains }), s).then((r) => {
          n(r);
        }).catch((r) => {
          h(new Error(r.message));
        });
      }), e = i.session;
      if (e) {
        const n = Kr(e.namespaces, [this.namespace]);
        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit("connect", { chainId: C(this.chainId) });
      }
      return i;
    } catch (i) {
      throw this.signer.logger.error(i), i;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t) => {
      const { params: s } = t, { event: i } = s;
      i.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i.data), this.events.emit("accountsChanged", this.accounts)) : i.name === "chainChanged" ? this.setChainId(this.formatChainId(i.data)) : this.events.emit(i.name, i.data), this.events.emit("session_event", t);
    }), this.signer.on("chainChanged", (t) => {
      const s = parseInt(t);
      this.chainId = s, this.events.emit("chainChanged", C(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t) => {
      this.events.emit("session_update", t);
    }), this.signer.on("session_delete", (t) => {
      this.reset(), this.events.emit("session_delete", t), this.events.emit("disconnect", _(g({}, de("USER_DISCONNECTED")), { data: t.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t) => {
      var s, i;
      this.rpc.showQrModal && ((s = this.modal) == null || s.closeModal(), (i = this.modal) == null || i.openModal({ uri: t })), this.events.emit("display_uri", t);
    });
  }
  switchEthereumChain(t) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t.toString(16) }] });
  }
  isCompatibleChainId(t) {
    return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t) {
    return `${this.namespace}:${t}`;
  }
  parseChainId(t) {
    return Number(t.split(":")[1]);
  }
  setChainIds(t) {
    const s = t.filter((i) => this.isCompatibleChainId(i)).map((i) => this.parseChainId(i));
    s.length && (this.chainId = s[0], this.events.emit("chainChanged", C(this.chainId)), this.persist());
  }
  setChainId(t) {
    if (this.isCompatibleChainId(t)) {
      const s = this.parseChainId(t);
      this.chainId = s, this.switchEthereumChain(s);
    }
  }
  parseAccountId(t) {
    const [s, i, e] = t.split(":");
    return { chainId: `${s}:${i}`, address: e };
  }
  setAccounts(t) {
    this.accounts = t.filter((s) => this.parseChainId(this.parseAccountId(s).chainId) === this.chainId).map((s) => this.parseAccountId(s).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t) {
    var s, i;
    const e = (s = t == null ? void 0 : t.chains) != null ? s : [], n = (i = t == null ? void 0 : t.optionalChains) != null ? i : [], h = e.concat(n);
    if (!h.length)
      throw new Error("No chains specified in either `chains` or `optionalChains`");
    const l = e.length ? (t == null ? void 0 : t.methods) || u : [], r = e.length ? (t == null ? void 0 : t.events) || m : [], d = (t == null ? void 0 : t.optionalMethods) || [], c = (t == null ? void 0 : t.optionalEvents) || [], I = (t == null ? void 0 : t.rpcMap) || this.buildRpcMap(h, t.projectId), f = (t == null ? void 0 : t.qrModalOptions) || void 0;
    return { chains: e == null ? void 0 : e.map((p) => this.formatChainId(p)), optionalChains: n.map((p) => this.formatChainId(p)), methods: l, events: r, optionalMethods: d, optionalEvents: c, rpcMap: I, showQrModal: !!(t != null && t.showQrModal), qrModalOptions: f, projectId: t.projectId, metadata: t.metadata };
  }
  buildRpcMap(t, s) {
    const i = {};
    return t.forEach((e) => {
      i[e] = this.getRpcUrl(e, s);
    }), i;
  }
  async initialize(t) {
    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? v(this.rpc.chains) : v(this.rpc.optionalChains), this.signer = await es.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t.disableProviderPing, relayUrl: t.relayUrl, storage: t.storage, storageOptions: t.storageOptions, customStoragePrefix: t.customStoragePrefix, telemetryEnabled: t.telemetryEnabled, logger: t.logger }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let s;
      try {
        const { WalletConnectModal: i } = await import("./dist-BWMQ3M2G.js");
        s = i;
      } catch {
        throw new Error("To use QR modal, please install @walletconnect/modal package");
      }
      if (s)
        try {
          this.modal = new s(g({ projectId: this.rpc.projectId }, this.rpc.qrModalOptions));
        } catch (i) {
          throw this.signer.logger.error(i), new Error("Could not generate WalletConnectModal Instance");
        }
    }
  }
  loadConnectOpts(t) {
    if (!t)
      return;
    const { chains: s, optionalChains: i, rpcMap: e } = t;
    s && $e(s) && (this.rpc.chains = s.map((n) => this.formatChainId(n)), s.forEach((n) => {
      this.rpc.rpcMap[n] = (e == null ? void 0 : e[n]) || this.getRpcUrl(n);
    })), i && $e(i) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i == null ? void 0 : i.map((n) => this.formatChainId(n)), i.forEach((n) => {
      this.rpc.rpcMap[n] = (e == null ? void 0 : e[n]) || this.getRpcUrl(n);
    }));
  }
  getRpcUrl(t, s) {
    var i;
    return ((i = this.rpc.rpcMap) == null ? void 0 : i[t]) || `${q}?chainId=eip155:${t}&projectId=${s || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (this.session)
      try {
        const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), s = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];
        this.setChainIds(t ? [this.formatChainId(t)] : s == null ? void 0 : s.accounts), this.setAccounts(s == null ? void 0 : s.accounts);
      } catch (t) {
        this.signer.logger.error("Failed to load persisted session, clearing state..."), this.signer.logger.error(t), await this.disconnect().catch((s) => this.signer.logger.warn(s));
      }
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t) {
    return typeof t == "string" || t instanceof String ? [this.parseAccount(t)] : t.map((s) => this.parseAccount(s));
  }
};
var z = w;
export {
  z as EthereumProvider,
  O as OPTIONAL_EVENTS,
  M as OPTIONAL_METHODS,
  m as REQUIRED_EVENTS,
  u as REQUIRED_METHODS,
  w as default
};
//# sourceMappingURL=index.es-IT7U74FM.js.map
